
Now, youâ€™re ready to start doing some awesome things with TsFile. This section demonstrates the detailed usage of TsFile.

### Time-series Data
A time-series is considered as a set of quadruples. A quadruple is defined as (deltaObject, measurement, time, value).

* **deltaObject**: In many situations, a device which contains many sensors can be considered as a deltaObject.
* **measurement**: A sensor can be considered as a measurement


Table 1 illustrates a set of time-series data. The set showed in the following table contains one deltaObject named "device\_1" with three measurements named "sensor\_1", "sensor\_2" and "sensor\_3". 

<center>
<table style="text-align:center">
	<tr><th colspan="6">device_1</th></tr>
	<tr><th colspan="2">sensor_1</th><th colspan="2">sensor_2</th><th colspan="2">sensor_3</th></tr>
	<tr><th>time</th><th>value</td><th>time</th><th>value</td><th>time</th><th>value</td>
	<tr><td>1</td><td>1.2</td><td>1</td><td>20</td><td>2</td><td>50</td></tr>
	<tr><td>3</td><td>1.4</td><td>2</td><td>20</td><td>4</td><td>51</td></tr>
	<tr><td>5</td><td>1.1</td><td>3</td><td>21</td><td>6</td><td>52</td></tr>
	<tr><td>7</td><td>1.8</td><td>4</td><td>20</td><td>8</td><td>53</td></tr>
</table>
<span>A set of time-series data</span>
</center>

**One Line of Data**: In many industrial applications, a device normally contains more than one sensor and these sensors may have values at a same timestamp, which is called one line of data. 

Formally, one line of data consists of a `deltaObject_id`, a timestamp which indicates the milliseconds since January 1, 1970, 00:00:00, and several data pairs composed of `measurement_id` and corresponding `value`. All data pairs in one line belong to this `deltaObject_id` and have the same timestamp. If one of the `measurements` doesn't have a `value` in the `timestamp`, use a space instead(Actually, TsFile does not store null values). Its format is shown as follow:

```
deltaObject_id, timestamp, <measurement_id, value>...
```

An example is illustrated as follow. In this example, the data type of three measurements are  `INT32`, `FLOAT` and  `ENUMS` respectively.

```
device_1, 1490860659000, m1, 10, m2, 12.12, m3, MAN
```


### Writing TsFile

#### Generate a TsFile File.
A TsFile can be generated by following three steps and the complete code will be given in the section "Example for writing TsFile".

* First, use the interface to construct a TsFile instance.
	```
	public TsFileWriter(File file) throws WriteProcessException, IOException
	```
	
	**Parameters:**
	
	* file : The TsFile to write

* Second, add measurements

	```
	public void addMeasurement(MeasurementDescriptor measurementDescriptor) throws WriteProcessException
	```
	
	**Parameters:**
	
	* measurementDescriptor : The measurement information including name, data type and encoding
	
	Or use a json object
	```
	public void addMeasurementByJson(JSONObject measurement) throws WriteProcessException
	```
	**Parameters:**
    	
    * measurement : The Json object including name, data type, encoding, and compression type. See schema Json section 
    below.
    
    Note that although one measurement name can be used in multiple deltaObjects, the properties cannot be changed. I.e. 
    it's not allowed to add one measurement name for multiple times with different type or encoding.
    Here is a bad example:

    ```
    // The measurement "sensor_1" is float type
    addMeasurement(new MeasurementSchema("sensor_1", TSDataType.FLOAT, TSEncoding.RLE));
    // This call will cause a WriteProcessException exception
    addMeasurement(new MeasurementSchema("sensor_1", TSDataType.INT32, TSEncoding.RLE));
    ```
* Third, write data continually.
	
	```
	public void write(TSRecord record) throws IOException, WriteProcessException
	```
	
	Use this interface to create a new TSRecord(a timestamp and device pair).
	
	```
	public TSRecord(long timestamp, String deviceId)
	```
	Then create DataPoint(a measurement and value pair), and use the addTuple method to add the DataPoint to the correct
	TsRecord.
	
* Finally, call `close` to finish this writing process. 
	
	```
	public void close() throws IOException
	```

#### Format of Schema JSON
`SchemaJSON` is a schema array specifying a list of allowable time series. The schema describes each measurement's `measurement_id`, `data_type`, `encoding`, `compression type` , and
properties according to the specific data type.

An example is shown as follow:

``` json
{
    "schema": [
        {
            "measurement_id": "m1",
            "data_type": "INT32",
            "encoding": "RLE"
        },
        {
            "measurement_id": "m2",
            "data_type": "FLOAT",
            "encoding": "TS_2DIFF",
            "max_point_number": 2
        },
        {
            "measurement_id": "m3",
            "data_type": "ENUMS",
            "encoding": "BITMAP",
            "enum_values":["MAN","WOMAN"]
        },
        {
            "measurement_id": "m4",
            "data_type": "INT64",
            "encoding": "RLE",            
            "compressor": "SNAPPY"
        }
    ],
}
```
`SchemaJSON` consists of a `JSONArray` of schema objects . For each schema object, which corresponds to a time series, its field description is shown as follow:

| key      | is required|     description | allowed values|
| :-------- | --------:| :------:| :------:|
| measurement_id    |**required**	|name of the time series |any combination of letters, numbers and other symbols like `_` `.`  |
| data_type    		|**required**	|data type|`BOOLEAN`, `INT32`, `INT64`, `FLOAT`, `DOUBLE`, `ENUM` and `TEXT`(namely `String`)|
| encoding    		|**required**	| encoding approach for time domain. |`PLAIN`(for all data types), {`TS_2DIFF`, `RLE`}(for `INT32`, `INT64`, `FLOAT`, `DOUBLE`, `ENUM`), `BITMAP`(`ENUM`)|
| compressor    		|**required**	| the type of compression.| `SNAPPY` and `UNCOMPRESSED`|
| enum_values 		|required if `data_type` is `ENUM`	| the fields of `ENUM`  	|  in format of `["MAN","WOMAN"]`|
| max\_point\_number    		|optional	| the number of reserved decimal digits. It's useful if the data type is `FLOAT`, `DOUBLE` or `BigDecimal`| natural number, defaults to 2|
|max\_string\_length	|optional	| maximal length of string. It's useful if the data type is `TEXT`.  | positive integer, defaults to 128|



#### Example for writing TsFile

You should first install TsFile to your local maven repository.

reference: [Installation_0.7.0](https://github.com/thulab/tsfile/wiki/Installation_0.7.0)



##### Writing TsFile by using json schema

```java
package org.apache.iotdb.tsfile;

import java.io.File;
import java.io.IOException;
import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONObject;
import org.apache.iotdb.tsfile.exception.write.WriteProcessException;
import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;
import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;
import org.apache.iotdb.tsfile.write.TsFileWriter;
import org.apache.iotdb.tsfile.write.record.TSRecord;
import org.apache.iotdb.tsfile.write.record.datapoint.DataPoint;
import org.apache.iotdb.tsfile.write.record.datapoint.FloatDataPoint;
import org.apache.iotdb.tsfile.write.record.datapoint.IntDataPoint;
import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;
/**
 * An example of writing data to TsFile
 */
public class TsFileWrite {
  /**
   * There are two ways to construct a TsFile instance,they generate the identical TsFile file.
   * This method uses the first interface:
   * public void addMeasurementByJson(JSONObject measurement) throws WriteProcessException
   * The corresponding json string is provided below.
   * {
   *     "schema": [
   *         {
   *             "measurement_id": "sensor_1",
   *             "data_type": "FLOAT",
   *             "encoding": "RLE",
   * 	         "compressor" : "UNCOMPRESSED"
   *         },
   *         {
   *             "measurement_id": "sensor_2",
   *             "data_type": "INT32",
   *             "encoding": "TS_2DIFF",
   * 	         "compressor" : "UNCOMPRESSED"
   *         },
   *         {
   *             "measurement_id": "sensor_3",
   *             "data_type": "INT32",
   *             "encoding": "TS_2DIFF",
   * 	         "compressor" : "UNCOMPRESSED"
   *        }
   *     ]
   * }
   */
  public static void main(String args[]) {
    try {
         String path = "testWithJson.tsfile";
         String jsonText = "{\n" +
                 "    \"schema\": [\n" +
                 "        {\n" +
                 "            \"measurement_id\": \"sensor_1\",\n" +
                 "            \"data_type\": \"FLOAT\",\n" +
                 "            \"encoding\": \"RLE\",\n" +
                 "            \"compressor\" : \"UNCOMPRESSED\"\n" +
                 "        },\n" +
                 "        {\n" +
                 "            \"measurement_id\": \"sensor_2\",\n" +
                 "            \"data_type\": \"INT32\",\n" +
                 "            \"encoding\": \"TS_2DIFF\",\n" +
                 "            \"compressor\" : \"UNCOMPRESSED\"\n" +
                 "\n" +
                 "        },\n" +
                 "        {\n" +
                 "            \"measurement_id\": \"sensor_3\",\n" +
                 "            \"data_type\": \"INT32\",\n" +
                 "            \"encoding\": \"TS_2DIFF\",        \n" +
                 "            \"compressor\" : \"UNCOMPRESSED\"\n" +
                 "\n" +
                 "  }\n" +
                 "    ]\n" +
                 "}";
         File f = new File(path);
         if (f.exists()) {
           f.delete();
         }
         TsFileWriter tsFileWriter = new TsFileWriter(f);
         JSONObject j = JSONObject.parseObject(jsonText);
         JSONArray schemas = j.getJSONArray("schema");
         // add measurements into file schema
         for (int i = 0; i < schemas.size(); ++i) {
           tsFileWriter.addMeasurementByJson(schemas.getJSONObject(i));
         }
        // construct TSRecord
        TSRecord tsRecord = new TSRecord(1, "device_1");
        DataPoint dPoint1 = new FloatDataPoint("sensor_1", 1.2f);
        DataPoint dPoint2 = new IntDataPoint("sensor_2", 20);
        DataPoint dPoint3;
        tsRecord.addTuple(dPoint1);
        tsRecord.addTuple(dPoint2);
    
        // write a TSRecord to TsFile
        tsFileWriter.write(tsRecord);
    
        tsRecord = new TSRecord(2, "device_1");
        dPoint2 = new IntDataPoint("sensor_2", 20);
        dPoint3 = new IntDataPoint("sensor_3", 50);
        tsRecord.addTuple(dPoint2);
        tsRecord.addTuple(dPoint3);
        tsFileWriter.write(tsRecord);
    
        tsRecord = new TSRecord(3, "device_1");
        dPoint1 = new FloatDataPoint("sensor_1", 1.4f);
        dPoint2 = new IntDataPoint("sensor_2", 21);
        tsRecord.addTuple(dPoint1);
        tsRecord.addTuple(dPoint2);
        tsFileWriter.write(tsRecord);
    
        tsRecord = new TSRecord(4, "device_1");
        dPoint1 = new FloatDataPoint("sensor_1", 1.2f);
        dPoint2 = new IntDataPoint("sensor_2", 20);
        dPoint3 = new IntDataPoint("sensor_3", 51);
        tsRecord.addTuple(dPoint1);
        tsRecord.addTuple(dPoint2);
        tsRecord.addTuple(dPoint3);
        tsFileWriter.write(tsRecord);
    
        tsRecord = new TSRecord(6, "device_1");
        dPoint1 = new FloatDataPoint("sensor_1", 7.2f);
        dPoint2 = new IntDataPoint("sensor_2", 10);
        dPoint3 = new IntDataPoint("sensor_3", 11);
        tsRecord.addTuple(dPoint1);
        tsRecord.addTuple(dPoint2);
        tsRecord.addTuple(dPoint3);
        tsFileWriter.write(tsRecord);
    
        tsRecord = new TSRecord(7, "device_1");
        dPoint1 = new FloatDataPoint("sensor_1", 6.2f);
        dPoint2 = new IntDataPoint("sensor_2", 20);
        dPoint3 = new IntDataPoint("sensor_3", 21);
        tsRecord.addTuple(dPoint1);
        tsRecord.addTuple(dPoint2);
        tsRecord.addTuple(dPoint3);
        tsFileWriter.write(tsRecord);
    
        tsRecord = new TSRecord(8, "device_1");
        dPoint1 = new FloatDataPoint("sensor_1", 9.2f);
        dPoint2 = new IntDataPoint("sensor_2", 30);
        dPoint3 = new IntDataPoint("sensor_3", 31);
        tsRecord.addTuple(dPoint1);
        tsRecord.addTuple(dPoint2);
        tsRecord.addTuple(dPoint3);
        tsFileWriter.write(tsRecord);
    
        // close TsFile
        tsFileWriter.close();        
    } catch (Throwable e) {
      e.printStackTrace();
      System.out.println(e.getMessage());
    }
  }
}

```

##### Writing TsFile directly without defining the schema by json

```java
package org.apache.iotdb.tsfile;

import java.io.File;
import java.io.IOException;
import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONObject;
import org.apache.iotdb.tsfile.exception.write.WriteProcessException;
import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;
import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;
import org.apache.iotdb.tsfile.write.TsFileWriter;
import org.apache.iotdb.tsfile.write.record.TSRecord;
import org.apache.iotdb.tsfile.write.record.datapoint.DataPoint;
import org.apache.iotdb.tsfile.write.record.datapoint.FloatDataPoint;
import org.apache.iotdb.tsfile.write.record.datapoint.IntDataPoint;
import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;
/**
 * An example of writing data to TsFile
 */
public class TsFileWrite {
   /**
    * There are two ways to construct a TsFile instance,they generate the identical TsFile file.
    * This method uses the second interface:
    * public void addMeasurement(MeasurementSchema MeasurementSchema) throws WriteProcessException
    * The measurements are identical to the json string provided above.
    */
  public static void main(String args[]) {
    try {
        String path = "testDirect.tsfile";
        File f = new File(path);
        if (f.exists()) {
          f.delete();
        }
        TsFileWriter tsFileWriter = new TsFileWriter(f);
    
        // add measurements into file schema
        tsFileWriter
                .addMeasurement(new MeasurementSchema("sensor_1", TSDataType.FLOAT, TSEncoding.RLE));
        tsFileWriter
                .addMeasurement(new MeasurementSchema("sensor_2", TSDataType.INT32, TSEncoding.TS_2DIFF));
        tsFileWriter
                .addMeasurement(new MeasurementSchema("sensor_3", TSDataType.INT32, TSEncoding.TS_2DIFF));
        // construct TSRecord
        TSRecord tsRecord = new TSRecord(1, "device_1");
        DataPoint dPoint1 = new FloatDataPoint("sensor_1", 1.2f);
        DataPoint dPoint2 = new IntDataPoint("sensor_2", 20);
        DataPoint dPoint3;
        tsRecord.addTuple(dPoint1);
        tsRecord.addTuple(dPoint2);
    
        // write a TSRecord to TsFile
        tsFileWriter.write(tsRecord);
    
        tsRecord = new TSRecord(2, "device_1");
        dPoint2 = new IntDataPoint("sensor_2", 20);
        dPoint3 = new IntDataPoint("sensor_3", 50);
        tsRecord.addTuple(dPoint2);
        tsRecord.addTuple(dPoint3);
        tsFileWriter.write(tsRecord);
    
        tsRecord = new TSRecord(3, "device_1");
        dPoint1 = new FloatDataPoint("sensor_1", 1.4f);
        dPoint2 = new IntDataPoint("sensor_2", 21);
        tsRecord.addTuple(dPoint1);
        tsRecord.addTuple(dPoint2);
        tsFileWriter.write(tsRecord);
    
        tsRecord = new TSRecord(4, "device_1");
        dPoint1 = new FloatDataPoint("sensor_1", 1.2f);
        dPoint2 = new IntDataPoint("sensor_2", 20);
        dPoint3 = new IntDataPoint("sensor_3", 51);
        tsRecord.addTuple(dPoint1);
        tsRecord.addTuple(dPoint2);
        tsRecord.addTuple(dPoint3);
        tsFileWriter.write(tsRecord);
    
        tsRecord = new TSRecord(6, "device_1");
        dPoint1 = new FloatDataPoint("sensor_1", 7.2f);
        dPoint2 = new IntDataPoint("sensor_2", 10);
        dPoint3 = new IntDataPoint("sensor_3", 11);
        tsRecord.addTuple(dPoint1);
        tsRecord.addTuple(dPoint2);
        tsRecord.addTuple(dPoint3);
        tsFileWriter.write(tsRecord);
    
        tsRecord = new TSRecord(7, "device_1");
        dPoint1 = new FloatDataPoint("sensor_1", 6.2f);
        dPoint2 = new IntDataPoint("sensor_2", 20);
        dPoint3 = new IntDataPoint("sensor_3", 21);
        tsRecord.addTuple(dPoint1);
        tsRecord.addTuple(dPoint2);
        tsRecord.addTuple(dPoint3);
        tsFileWriter.write(tsRecord);
    
        tsRecord = new TSRecord(8, "device_1");
        dPoint1 = new FloatDataPoint("sensor_1", 9.2f);
        dPoint2 = new IntDataPoint("sensor_2", 30);
        dPoint3 = new IntDataPoint("sensor_3", 31);
        tsRecord.addTuple(dPoint1);
        tsRecord.addTuple(dPoint2);
        tsRecord.addTuple(dPoint3);
        tsFileWriter.write(tsRecord);
    
        // close TsFile
        tsFileWriter.close();        
    } catch (Throwable e) {
      e.printStackTrace();
      System.out.println(e.getMessage());
    }
  }
}
```

### Interface for Reading TsFile

#### Before the Start

The set of time-series data in section "Time-series Data" is used here for a concrete introduction in this section. The set showed in the following table contains one deltaObject named "device\_1" with three measurements named "sensor\_1", "sensor\_2" and "sensor\_3". And the measurements has been simplified to do a simple illustration, which contains only 4 time-value pairs each.

<center>
<table style="text-align:center">
	<tr><th colspan="6">device_1</th></tr>
	<tr><th colspan="2">sensor_1</th><th colspan="2">sensor_2</th><th colspan="2">sensor_3</th></tr>
	<tr><th>time</th><th>value</td><th>time</th><th>value</td><th>time</th><th>value</td>
	<tr><td>1</td><td>1.2</td><td>1</td><td>20</td><td>2</td><td>50</td></tr>
	<tr><td>3</td><td>1.4</td><td>2</td><td>20</td><td>4</td><td>51</td></tr>
	<tr><td>5</td><td>1.1</td><td>3</td><td>21</td><td>6</td><td>52</td></tr>
	<tr><td>7</td><td>1.8</td><td>4</td><td>20</td><td>8</td><td>53</td></tr>
</table>
<span>A set of time-series data</span>
</center>

#### Definition of Path

A path represents a series instance in TsFile. In the example given above, "device\_1.sensor\_1" is a path.

In read interfaces, The parameter ```paths``` indicates the measurements to be selected.

Path instance can be easily constructed through the class ```Path```. For example:

```
Path p = new Path("device_1.sensor_1");
```

If "sensor\_1" and "sensor\_3" need to be selected in a query, just use following codes.

```
List<Path> paths = new ArrayList<Path>();
paths.add(new Path("device_1.sensor_1"));
paths.add(new Path("device_1.sensor_3"));
```

> **Notice:** When constructing a Path, the format of the parameter should be "\<deltaObjectId\>.\<measurementId\>"


#### Definition of Filter

##### Usage Scenario
Filter is used in TsFile reading process to select data. 

##### IExpression
The IExpression is a filter expression and it will be passed to our final query call.
We create different `FilterSeries` and  use `FilterOperators` to combine them to our final IExpression object.

* **FilterSeries**
	
	There are two kinds of FilterSeries.
	
	 * TIME_FILTER: used to construct a filter for `time` in time-series data.
	 	
	 	```
	 	IExpression timeFilter = new GlobalTimeExpression(Filter);
	 	
	 		 		 * Lt: Less than
                	 * Gt: Greater than
                	 * Eq: Equals
       * NotEq: Not equals
	 	```
	 	
	 * VALUE_FILTER: used to construct a filter for `value` in time-series data.
	 	
	 	```
	 	FilterSeries valueSeries = FilterFactory.intFilterSeries(device_1, sensor_1, VALUE_FILTER);
	 	```
		The FilterSeries above defines a series 'device\_1.sensor\_1' whose data type is INT32 and FilterSeriesType is VALUE_FILTER.

* **FilterOperator**

	FilterOperator can be used to construct diverse filters.

	**Basic filter operation:**

	 * Not: Flip a filter
	 * And(left, right): Conjunction of two filters
	 * Or(left, right): Disjunction of two filters

##### How to build a FilterExpression

* **TimeFilterExpression Usage**

	First, define a FilterSeries with TIME_FILTER type.

	```
	FilterSeries timeSeries = FilterFactory.timeFilterSeries();
	```
	
	Then, construct FilterExpression. Some typical FilterExpression definitions are shown as below with the ```timeSeries``` defined above.

	```
	FilterExpression expression = FilterFactory.eq(timeSeries, 15); // series time = 15

	```
	```
	FilterExpression expression = FilterFactory.LtEq(timeSeries, 15, true); // series time <= 15

	```
	```
	FilterExpression expression = FilterFactory.LtEq(timeSeries, 15, false); // series time < 15

	```
	```
	FilterExpression expression = FilterFactory.GtEq(timeSeries, 15, true); // series time >= 15

	```
	```
	FilterExpression expression = FilterFactory.NotEq(timeSeries, 15); // series time != 15

	```
	```
	FilterExpression expression = FilterFactory.And( FilterFactory.GtEq(timeSeries, 15, true), FilterFactory.LtEq(timeSeries, 25, false)); // 15 <= series time < 25

	```
	```
	FilterExpression expression = FilterFactory.Or( FilterFactory.GtEq(timeSeries, 15, true), FilterFactory.LtEq(timeSeries, 25, false)); // series time >= 15 or series time < 25

	```
* **ValueFilterExpression Usage**

	First, define a FilterSeries with VALUE_FILTER type.

	```
	FilterSeries valueSeries = FilterFactory.intFilterSeries(root.beijing.vehicle, car, VALUE_FILTER);
	```

	Then, construct FilterExpression. Some typical FilterExpression definitions are shown as below with the ```valueSeries``` defined above

	```
	FilterExpression expression = FilterFactory.eq(valueSeries, 15); // series value = 15

	```
	```
	FilterExpression expression = FilterFactory.LtEq(valueSeries, 15, true); // series value <= 15

	```

#### Read Interface

The method ```query()``` can be used to read from a TsFile. In class ```TsFile```, two override metheds named *query* are supported. Concrete description is as follow:

* **Method 1**

	```
	QueryDataSet query(	List<Path> paths,
						FilterExpression timeFilter,
						FilterExpression valueFilter
						) throws IOException
	```

	**Parameters:**

	* paths : selected `Series`
	* timeFilter : filter for timestamps. Input ```null``` if timeFilter is not required.
	* valueFitler : filter for specific series. Input ```null``` if valueFilter is not required.

	> **What does valueFilter mean in a query ?**

	> When executing a query in TsFile, all series involved will be viewed as a "Table". In this special Table, there are (1 + n) columns where "n" is the count of series and "1" indicates the column of timestamp.
	>
	> Fields in timestamp column is the union of timestamps from each series involved, which is in ascending order. Then each field of the series column is the value in corsponding timestamps or null instead.
	>
	> For example, the query parameters is :
	>
	> * paths : ["device\_1.sensor\_1","device\_1.sensor\_3"]
	> * timeFilter : timestamp <= 3
	> * valueFilter : device\_1.sensor\_3 <= 51 or device\_1.sensor\_1 < 1.4
	>
	> The virtual "Table" is:
	>	<table style="text-align:center">
	<tr><th>timestamp</th><th>device_1.sensor_1</th><th>device_1.sensor_2</th><th>device_1.sensor_3</th></tr>
	<tr><td>1</td><td>1.2</td><td>20</td><td>null</td></tr>
	<tr><td>2</td><td>null</td><td>20</td><td>50</td></tr>
	<tr><td>3</td><td>1.4</td><td>21</td><td>null</td></tr>
	<tr><td>4</td><td>null</td><td>20</td><td>51</td></tr>
	<tr><td>5</td><td>1.1</td><td>null</td><td>null</td></tr>
	<tr><td>6</td><td>null</td><td>null</td><td>52</td></tr>
	<tr><td>7</td><td>1.8</td><td>null</td><td>null</td></tr>
	<tr><td>8</td><td>null</td><td>null</td><td>53</td></tr>
	</table>
	>Then the result is:
	>	<table style="text-align:center">
	<tr><th>timestamp</th><th>device_1.sensor_1</th><th>device_1.sensor_3</th></tr>
	<tr><td>1</td><td>1.2</td><td>20</td></tr>
	<tr><td>2</td><td>null</td><td>20</tr>
	</table>

* **Method 2**

	```
	QueryDataSet query(	List<Path> paths,
						FilterExpression timeFilter,
						FilterExpression valueFilter,
						Map<String, Long> params
						) throws IOException
	```

	This method is designed for advanced applications such as the TsFile-Spark Connector. The differences from Method 1 is that this method has an additional parameter named "params".

	* **params** : This parameter is a Map instance which stores some additional options for a specific query. In current version, a partial query is supported by adding two options to this parameter.
		*  ```QueryConstant.PARTITION_START_OFFSET```: start offset for a TsFile
		*  ```QueryConstant.PARTITION_END_OFFSET```: end offset for a TsFile

		> **What is Partial Query ?**
		>
		> In some distributed file systems(e.g. HDFS), a file is split into severval parts which are called "Blocks" and stored in different nodes. Executing a query paralleled in each nodes involved makes better efficiency. Thus Partial Query is needed. Paritial Query only selects the results stored in the part split by ```QueryConstant.PARTITION_START_OFFSET``` and ```QueryConstant.PARTITION_END_OFFSET``` for a TsFile.

#### Example

You should install TsFile to your local maven repository.

reference: [Installation_0.4.0](https://github.com/thulab/tsfile/wiki/Installation_0.4.0)


```java
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.iotdb.tsfile;
import java.io.IOException;
import java.util.ArrayList;
import org.apache.iotdb.tsfile.read.ReadOnlyTsFile;
import org.apache.iotdb.tsfile.read.TsFileSequenceReader;
import org.apache.iotdb.tsfile.read.common.Path;
import org.apache.iotdb.tsfile.read.expression.IExpression;
import org.apache.iotdb.tsfile.read.expression.QueryExpression;
import org.apache.iotdb.tsfile.read.expression.impl.BinaryExpression;
import org.apache.iotdb.tsfile.read.expression.impl.GlobalTimeExpression;
import org.apache.iotdb.tsfile.read.expression.impl.SingleSeriesExpression;
import org.apache.iotdb.tsfile.read.filter.TimeFilter;
import org.apache.iotdb.tsfile.read.filter.ValueFilter;
import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;

/**
 * The class is to show how to read TsFile file named "testDirect.tsfile".
 * The TsFile file "testDirect.tsfile" is generated from class TsFileWrite.
 * It generates the same TsFile(testDirect.tsfile and testWithJson.tsfile) file by two different ways
 * Run TsFileWrite to generate the testDirect.tsfile first
 */
public class TsFileRead {
  private static void queryAndPrint(ArrayList<Path> paths, ReadOnlyTsFile readTsFile, IExpression statement)
          throws IOException {
    QueryExpression queryExpression = QueryExpression.create(paths, statement);
    QueryDataSet queryDataSet = readTsFile.query(queryExpression);
    while (queryDataSet.hasNext()) {
      System.out.println(queryDataSet.next());
    }
    System.out.println("------------");
  }

  public static void main(String[] args) throws IOException {

    // file path
    String path = "testDirect.tsfile";

    // create reader and get the readTsFile interface
    TsFileSequenceReader reader = new TsFileSequenceReader(path);
    ReadOnlyTsFile readTsFile = new ReadOnlyTsFile(reader);
    // use these paths(all sensors) for all the queries
    ArrayList<Path> paths = new ArrayList<>();
    paths.add(new Path("device_1.sensor_1"));
    paths.add(new Path("device_1.sensor_2"));
    paths.add(new Path("device_1.sensor_3"));

    // no filter, should select 1 2 3 4 6 7 8
    queryAndPrint(paths, readTsFile, null);

    // time filter : 4 <= time <= 10, should select 4 6 7 8
    IExpression timeFilter = BinaryExpression.and(new GlobalTimeExpression(TimeFilter.gtEq(4L)),
        new GlobalTimeExpression(TimeFilter.ltEq(10L)));
    queryAndPrint(paths, readTsFile, timeFilter);

    // value filter : device_1.sensor_2 <= 20, should select 1 2 4 6 7
    IExpression valueFilter = new SingleSeriesExpression(new Path("device_1.sensor_2"),
        ValueFilter.ltEq(20));
    queryAndPrint(paths, readTsFile, valueFilter);

    // time filter : 4 <= time <= 10, value filter : device_1.sensor_3 >= 20, should select 4 7 8
    timeFilter = BinaryExpression.and(new GlobalTimeExpression(TimeFilter.gtEq(4L)),
        new GlobalTimeExpression(TimeFilter.ltEq(10L)));
    valueFilter = new SingleSeriesExpression(new Path("device_1.sensor_3"), ValueFilter.gtEq(20));
    IExpression finalFilter = BinaryExpression.and(timeFilter, valueFilter);
    queryAndPrint(paths, readTsFile, finalFilter);

    //close the reader when you left
    reader.close();
  }
}
```

### User-specified config file path

Default config file `tsfile-format.properties.template` is located at `/tsfile/src/main/resources` directory. If you want to use your own path, you can:
```
System.setProperty(SystemConstant.TSFILE_CONF, "your config file path");
```
and then call:
```
TSFileConfig config = TSFileDescriptor.getInstance().getConfig();
```


